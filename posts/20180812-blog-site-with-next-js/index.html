<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head next-head"/><meta charset="utf-8" class="next-head"/><meta http-equiv="X-UA-Compatible" content="IE=edge" class="next-head"/><meta name="viewport" content="width=device-width, initial-scale=1" class="next-head"/><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous" class="next-head"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css" class="next-head"/><link rel="shortcut icon" type="image/x-icon" href="/static/favicon.ico" class="next-head"/><title class="next-head">Next.jsを使って簡単なブログを作りました</title><meta name="description" content="arizuk.github.io" class="next-head"/><meta name="author" content="Masaki Arizuka" class="next-head"/><link rel="preload" href="/_next/c858961e-8b9a-4e3e-9650-21c1f102a408/page/_post_content.js" as="script"/><link rel="preload" href="/_next/c858961e-8b9a-4e3e-9650-21c1f102a408/page/_app.js" as="script"/><link rel="preload" href="/_next/c858961e-8b9a-4e3e-9650-21c1f102a408/page/_error.js" as="script"/><link rel="preload" href="/_next/static/commons/main-47ca0585de64e6c09ce5.js" as="script"/><link rel="stylesheet" href="/_next/static/style.css"/></head><body><div id="__next"><div><div><aside class="header"><ul class="nav"><li><a href="/">About</a></li><li><a href="/posts/">Posts</a></li></ul><div class="logo"><a href="/"><img src="https://avatars0.githubusercontent.com/u/923924?v=4" class="logo-avatar"/></a></div></aside><div id="content"><article class="post"><div class="center"><h1>Next.jsを使って簡単なブログを作りました</h1><time class="code">August 12, 2018</time></div><div class="divider"></div><div class="markdown"><h2>モチベーション</h2>
<p>server/clientを同一言語で書いた場合楽なんだろうか？ という疑問の解消のために、SSRを試して見たかったので、<a href="https://github.com/zeit/next.js">Next.js</a>を使って自分用のブログサイトを作ってみました。Next.jsだとSSRに加えて、server側を簡単に静的ファイル化できそうだったので使ってみることにしました。(※他のフレームワークは詳しく見てません)</p>
<h2>Repository</h2>
<p><a href="https://github.com/arizuk/arizuk.github.io">https://github.com/arizuk/arizuk.github.io</a></p>
<h2>要件</h2>
<ul>
<li>SPA &amp;&amp; SSR</li>
<li>markdownファイルから動的にページが生成されること</li>
<li>github-pagesで静的ホスティングができること</li>
</ul>
<h2>markdownによる記事作成</h2>
<h3>dynamic routing</h3>
<p><code>exportPathMap</code>を動的に生成することで対応しました。この設定は静的ファイルをexportする際にも有効になります。</p>
<pre><code class="hljs"># next.config.js
<span class="hljs-keyword">const</span> getRoutes = <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> pathMap = {
    <span class="hljs-string">'/'</span>:  { page: <span class="hljs-string">'/index'</span> },
    <span class="hljs-string">'/posts'</span>:  { page: <span class="hljs-string">'/posts'</span> },
  };

  <span class="hljs-keyword">const</span> posts = <span class="hljs-built_in">JSON</span>.parse(fs.readFileSync(<span class="hljs-string">'./static/posts.json'</span>, <span class="hljs-string">'utf-8'</span>));
  <span class="hljs-keyword">return</span> posts.reduce(<span class="hljs-function">(<span class="hljs-params">map, post</span>) =&gt;</span> {
    map[<span class="hljs-string">`/posts/<span class="hljs-subst">${post.href}</span>`</span>] = { page: <span class="hljs-string">'/_post_content'</span>, query: { id: post.href } }
    <span class="hljs-keyword">return</span> map;
  }, pathMap);
};

<span class="hljs-built_in">module</span>.exports = {
  exportPathMap: getRoutes,
};
</code></pre>
<p><a href="https://github.com/arizuk/arizuk.github.io/blob/f1ab8fbc48c74f9e5186aded4389ae95ce8e7a61/next.config.js#L4">コード</a></p>
<h3>markdownのレンダリング</h3>
<p><code>getInitialProps</code>内部でclient/serverの判定はできるので、</p>
<ul>
<li>serverの場合は、filesystemからmarkdownを読み込む</li>
<li>clientの場合は、serverからmarkdownファイルをfetchする</li>
</ul>
<p>という<a href="https://github.com/arizuk/arizuk.github.io/blob/f1ab8fbc48c74f9e5186aded4389ae95ce8e7a61/utils/index.js#L43">実装</a>にしました。</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> readFile = <span class="hljs-keyword">async</span> () =&gt; { <span class="hljs-comment">/*...*/</span> };

<span class="hljs-keyword">const</span> getPostContentFromFs = <span class="hljs-keyword">async</span> (fname) =&gt; {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> readFile(<span class="hljs-string">`static/posts/<span class="hljs-subst">${fname}</span>`</span>);
};

<span class="hljs-keyword">const</span> getPostContentFromServer = <span class="hljs-keyword">async</span> (fname) =&gt; {
  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">`/static/posts/<span class="hljs-subst">${fname}</span>`</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> res.text();
};

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getPostContent</span>(<span class="hljs-params">fname</span>) </span>{
  <span class="hljs-keyword">if</span> (process.browser) {
    <span class="hljs-keyword">return</span> getPostContentFromServer(fname);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> getPostContentFromFs(fname);
  }
};
</code></pre>
<p>Next.jsの場合、コードはUniversalである必要があり、fsモジュールをimportするには、次のような<a href="https://github.com/arizuk/arizuk.github.io/blob/f1ab8fbc48c74f9e5186aded4389ae95ce8e7a61/next.config.js#L20">設定</a>が
必要でした。</p>
<pre><code class="hljs"><span class="hljs-meta"># next.config.js</span>
<span class="hljs-keyword">module</span>.exports = {
  webpack(<span class="hljs-built_in">config</span>) {
    <span class="hljs-built_in">config</span>.node = {
      fs: <span class="hljs-string">'empty'</span>,
    };
    <span class="hljs-built_in">return</span> <span class="hljs-built_in">config</span>;
  }
};
</code></pre>
<p>SSRに詳しくないのであれですが、この手の分岐が増えるとメンテナンスはしにくくなるので、本来はserver側でも<code>fetch</code>してくるのが筋なのかもしれません。</p>
<h2>github-pagesでの静的ホスティング</h2>
<p>今回は <code>&lt;username&gt;.github.io</code> でホスティングをしたかったので、ちょっとだけ工夫をしました。</p>
<p>細かい説明は省きますが、以下のような構成にしました</p>
<ul>
<li>master branch
<ul>
<li>配信する静的ファイルをroot直下に含む</li>
<li><code>git branch -d master &amp;&amp; git checkout --orphan master</code> でブランチを切る</li>
<li><code>touch .nojekyll</code></li>
</ul>
</li>
<li>docs branch
<ul>
<li>ソースコードを含む</li>
<li><code>out</code>ディレクトリに<code>next export</code>で静的ファイルを出力する</li>
<li><code>out</code>ディレクトリはgit管理化から外す</li>
<li><code>git worktree add out master</code>で<code>out</code>ディレクトリをmaster branchの作業ディレクトリにする</li>
</ul>
</li>
</ul>
<p>上記構成にしておけば、docs branchで生成物をexportして、<code>out</code>ディレクトリでcommit &amp;&amp; pushすればgithub pagesが更新されます。branchの切り替えもしなくて良いので楽です。</p>
<h2>CSS周り</h2>
<p>CSS及びデザインはさっぱりできないので、多きな声では言えないのですが、jekyllのthemesから拝借してごにょごにょしました。</p>
<p>styleの設定に<a href="https://github.com/zeit/styled-jsx">styled-jsx</a>を一部使ってみたんですが、</p>
<ul>
<li>scss等のsyntaxが使えない</li>
<li>vscodeでデフォルトでは補完が効かない</li>
<li>cssが長くなった場合、見通しが悪い</li>
</ul>
<p>と、あまり良い印象は受けませんでした。CSSとJSの分離は技術の分離であって関心事の分離ではないとか、いう意見もありましたが、分離したほうが圧倒的に開発しやすいという印象です。やっぱり個人的には、VueのSingle file components派です。</p>
<h2>所感</h2>
<p>Next.js, service workerを使ったprefetchなんかも対応中らしいので、SPA/SSRで高速に動く小さいサイトを手早く作るには簡単だし便利なのではないでしょうか。</p>
<h2>参考</h2>
<p><a href="http://ganow.me/article/blog-system-configuration">http://ganow.me/article/blog-system-configuration</a></p>
</div></article><div class="page-navigation code"><a title="back to index" href="/posts/">Index</a></div></div><div class="footer"><span class="block">© 2018 arizuk</span></div></div></div></div><div id="__next-error"></div><script>
          __NEXT_DATA__ = {"props":{"pageProps":{"title":"Next.jsを使って簡単なブログを作りました","date":"20180812","html":"\u003ch2\u003eモチベーション\u003c/h2\u003e\n\u003cp\u003eserver/clientを同一言語で書いた場合楽なんだろうか？ という疑問の解消のために、SSRを試して見たかったので、\u003ca href=\"https://github.com/zeit/next.js\"\u003eNext.js\u003c/a\u003eを使って自分用のブログサイトを作ってみました。Next.jsだとSSRに加えて、server側を簡単に静的ファイル化できそうだったので使ってみることにしました。(※他のフレームワークは詳しく見てません)\u003c/p\u003e\n\u003ch2\u003eRepository\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/arizuk/arizuk.github.io\"\u003ehttps://github.com/arizuk/arizuk.github.io\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003e要件\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSPA \u0026amp;\u0026amp; SSR\u003c/li\u003e\n\u003cli\u003emarkdownファイルから動的にページが生成されること\u003c/li\u003e\n\u003cli\u003egithub-pagesで静的ホスティングができること\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003emarkdownによる記事作成\u003c/h2\u003e\n\u003ch3\u003edynamic routing\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eexportPathMap\u003c/code\u003eを動的に生成することで対応しました。この設定は静的ファイルをexportする際にも有効になります。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e# next.config.js\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getRoutes = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pathMap = {\n    \u003cspan class=\"hljs-string\"\u003e'/'\u003c/span\u003e:  { page: \u003cspan class=\"hljs-string\"\u003e'/index'\u003c/span\u003e },\n    \u003cspan class=\"hljs-string\"\u003e'/posts'\u003c/span\u003e:  { page: \u003cspan class=\"hljs-string\"\u003e'/posts'\u003c/span\u003e },\n  };\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e posts = \u003cspan class=\"hljs-built_in\"\u003eJSON\u003c/span\u003e.parse(fs.readFileSync(\u003cspan class=\"hljs-string\"\u003e'./static/posts.json'\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e'utf-8'\u003c/span\u003e));\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e posts.reduce(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003emap, post\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    map[\u003cspan class=\"hljs-string\"\u003e`/posts/\u003cspan class=\"hljs-subst\"\u003e${post.href}\u003c/span\u003e`\u003c/span\u003e] = { page: \u003cspan class=\"hljs-string\"\u003e'/_post_content'\u003c/span\u003e, query: { id: post.href } }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e map;\n  }, pathMap);\n};\n\n\u003cspan class=\"hljs-built_in\"\u003emodule\u003c/span\u003e.exports = {\n  exportPathMap: getRoutes,\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/arizuk/arizuk.github.io/blob/f1ab8fbc48c74f9e5186aded4389ae95ce8e7a61/next.config.js#L4\"\u003eコード\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003emarkdownのレンダリング\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003egetInitialProps\u003c/code\u003e内部でclient/serverの判定はできるので、\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eserverの場合は、filesystemからmarkdownを読み込む\u003c/li\u003e\n\u003cli\u003eclientの場合は、serverからmarkdownファイルをfetchする\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eという\u003ca href=\"https://github.com/arizuk/arizuk.github.io/blob/f1ab8fbc48c74f9e5186aded4389ae95ce8e7a61/utils/index.js#L43\"\u003e実装\u003c/a\u003eにしました。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e readFile = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e () =\u0026gt; { \u003cspan class=\"hljs-comment\"\u003e/*...*/\u003c/span\u003e };\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getPostContentFromFs = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (fname) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e readFile(\u003cspan class=\"hljs-string\"\u003e`static/posts/\u003cspan class=\"hljs-subst\"\u003e${fname}\u003c/span\u003e`\u003c/span\u003e);\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getPostContentFromServer = \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e (fname) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e fetch(\u003cspan class=\"hljs-string\"\u003e`/static/posts/\u003cspan class=\"hljs-subst\"\u003e${fname}\u003c/span\u003e`\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e res.text();\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003egetPostContent\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efname\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (process.browser) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e getPostContentFromServer(fname);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e getPostContentFromFs(fname);\n  }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext.jsの場合、コードはUniversalである必要があり、fsモジュールをimportするには、次のような\u003ca href=\"https://github.com/arizuk/arizuk.github.io/blob/f1ab8fbc48c74f9e5186aded4389ae95ce8e7a61/next.config.js#L20\"\u003e設定\u003c/a\u003eが\n必要でした。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs\"\u003e\u003cspan class=\"hljs-meta\"\u003e# next.config.js\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003emodule\u003c/span\u003e.exports = {\n  webpack(\u003cspan class=\"hljs-built_in\"\u003econfig\u003c/span\u003e) {\n    \u003cspan class=\"hljs-built_in\"\u003econfig\u003c/span\u003e.node = {\n      fs: \u003cspan class=\"hljs-string\"\u003e'empty'\u003c/span\u003e,\n    };\n    \u003cspan class=\"hljs-built_in\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003econfig\u003c/span\u003e;\n  }\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSSRに詳しくないのであれですが、この手の分岐が増えるとメンテナンスはしにくくなるので、本来はserver側でも\u003ccode\u003efetch\u003c/code\u003eしてくるのが筋なのかもしれません。\u003c/p\u003e\n\u003ch2\u003egithub-pagesでの静的ホスティング\u003c/h2\u003e\n\u003cp\u003e今回は \u003ccode\u003e\u0026lt;username\u0026gt;.github.io\u003c/code\u003e でホスティングをしたかったので、ちょっとだけ工夫をしました。\u003c/p\u003e\n\u003cp\u003e細かい説明は省きますが、以下のような構成にしました\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003emaster branch\n\u003cul\u003e\n\u003cli\u003e配信する静的ファイルをroot直下に含む\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egit branch -d master \u0026amp;\u0026amp; git checkout --orphan master\u003c/code\u003e でブランチを切る\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etouch .nojekyll\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003edocs branch\n\u003cul\u003e\n\u003cli\u003eソースコードを含む\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eout\u003c/code\u003eディレクトリに\u003ccode\u003enext export\u003c/code\u003eで静的ファイルを出力する\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eout\u003c/code\u003eディレクトリはgit管理化から外す\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egit worktree add out master\u003c/code\u003eで\u003ccode\u003eout\u003c/code\u003eディレクトリをmaster branchの作業ディレクトリにする\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e上記構成にしておけば、docs branchで生成物をexportして、\u003ccode\u003eout\u003c/code\u003eディレクトリでcommit \u0026amp;\u0026amp; pushすればgithub pagesが更新されます。branchの切り替えもしなくて良いので楽です。\u003c/p\u003e\n\u003ch2\u003eCSS周り\u003c/h2\u003e\n\u003cp\u003eCSS及びデザインはさっぱりできないので、多きな声では言えないのですが、jekyllのthemesから拝借してごにょごにょしました。\u003c/p\u003e\n\u003cp\u003estyleの設定に\u003ca href=\"https://github.com/zeit/styled-jsx\"\u003estyled-jsx\u003c/a\u003eを一部使ってみたんですが、\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003escss等のsyntaxが使えない\u003c/li\u003e\n\u003cli\u003evscodeでデフォルトでは補完が効かない\u003c/li\u003e\n\u003cli\u003ecssが長くなった場合、見通しが悪い\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eと、あまり良い印象は受けませんでした。CSSとJSの分離は技術の分離であって関心事の分離ではないとか、いう意見もありましたが、分離したほうが圧倒的に開発しやすいという印象です。やっぱり個人的には、VueのSingle file components派です。\u003c/p\u003e\n\u003ch2\u003e所感\u003c/h2\u003e\n\u003cp\u003eNext.js, service workerを使ったprefetchなんかも対応中らしいので、SPA/SSRで高速に動く小さいサイトを手早く作るには簡単だし便利なのではないでしょうか。\u003c/p\u003e\n\u003ch2\u003e参考\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"http://ganow.me/article/blog-system-configuration\"\u003ehttp://ganow.me/article/blog-system-configuration\u003c/a\u003e\u003c/p\u003e\n"}},"page":"/_post_content","pathname":"/_post_content","query":{"id":"20180812-blog-site-with-next-js"},"buildId":"c858961e-8b9a-4e3e-9650-21c1f102a408","assetPrefix":"","nextExport":true,"err":null,"chunks":[]}
          module={}
          __NEXT_LOADED_PAGES__ = []
          __NEXT_LOADED_CHUNKS__ = []

          __NEXT_REGISTER_PAGE = function (route, fn) {
            __NEXT_LOADED_PAGES__.push({ route: route, fn: fn })
          }

          __NEXT_REGISTER_CHUNK = function (chunkName, fn) {
            __NEXT_LOADED_CHUNKS__.push({ chunkName: chunkName, fn: fn })
          }

          false
        </script><script async="" id="__NEXT_PAGE__/_post_content" src="/_next/c858961e-8b9a-4e3e-9650-21c1f102a408/page/_post_content.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/_next/c858961e-8b9a-4e3e-9650-21c1f102a408/page/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/_next/c858961e-8b9a-4e3e-9650-21c1f102a408/page/_error.js"></script><script src="/_next/static/commons/main-47ca0585de64e6c09ce5.js" async=""></script></body></html>